# Real World Review: Tic Tac Toe

## üìù Your Notes

Elaborate on your learnings here in `src/exercise/04.md`

## Background

A `username` is one thing, but a real UI is a bit different. Often you need more
than one element of state in your component, so you'll call `React.useState`
more than once. Please note that each call to `React.useState` in a given
component will give you a unique state and updater function. So this works:

```tsx
const [stateA, setStateA] = React.useState('a')
const [stateTwo, setStateTwo] = React.useState(2)
```

Another thing to learn about `useState` is the state updater function (like our
`setUsername` we've used before) can actually accept a function. For example:

```tsx
const [count, setCount] = React.useState(0)

// then in a click event handler or something:
setCount(count + 1)

// but this is the exact same thing:
setCount(previousCount => previousCount + 1)
```

Because there are two ways to do the same thing, it's nice to know why/when
you'd use one over the other. Here's the "rule":

**If your new value for state is calculated based on the previous value of
state, use the function form. Otherwise, either works fine.**

For a deeper dive on this, read
[useState lazy initialization and function updates](https://kentcdodds.com/blog/use-state-lazy-initialization-and-function-updates)
and check
[`examples/set-state-callback.tsx`](http://localhost:3000/isolated/examples/set-state-callback.tsx).

Some of our state updates rely on the current value of state so make sure you
avoid problems by using the function form.

This one's a bit tougher than some of the other exercises, so make sure you're
well hydrated and do a bit of stretching before starting this. Now might also be
a good time to make sure you have
[the React DevTools installed](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi)
and use that while debugging.

## Exercise

Production deploys:

- [Exercise](https://react-hooks-next.netlify.app/isolated/exercise/04.tsx)
- [Final](https://react-hooks-next.netlify.app/isolated/final/04.tsx)

We're going to build tic-tac-toe (with localStorage support)! If you've gone
through React's official tutorial, this was lifted from that (except that
example still uses classes).

You're going to need some managed state and some derived state. Remember from
exercise 1:

- **Managed State:** State that you need to explicitly manage
- **Derived State:** State that you can calculate based on other state

`squares` is the managed state and it's the state of the board in a
single-dimensional array:

```
[
  'X', 'O', 'X',
  'X', 'O', 'O',
  'X', 'X', 'O'
]
```

This will start out as an empty array because it's the start of the game.

`nextValue` will be either the string `X` or `O` and is derived state which you
can determine based on the value of `squares`. We can determine whose turn it is
based on how many "X" and "O" squares there are. We've written this out for you
in a `calculateNextValue` function in the `tic-tac-toe-utils.tsx` file.

`winner` will be either the string `X` or `O` and is derived state which can
also be determined based on the value of `squares` and we've provided a
`calculateWinner` function you can use to get that value.

If you want to try this exercise on beast mode then you can ignore
`calculateNextValue` and `calculateWinner` and write your own version of those
utilities.

## Extra Credit

### 1. üíØ preserve state in localStorage

[Production deploy](https://react-hooks-next.netlify.app/isolated/final/04.extra-1.tsx)

üë®‚Äçüíº Our customers want to be able to close the tab in the middle of a game and
then resume the game later. Can you store the game's state in `localStorage`?

### 2. üíØ useLocalStorageState

[Production deploy](https://react-hooks-next.netlify.app/isolated/final/04.extra-2.tsx)

It's cool that we can get localStorage support with a simple `useEffect`, but
it'd be even cooler to use the `useLocalStorageState` hook that's already
written for us in `src/utils.js`!

Refactor your code to use that custom hook instead. (This should be a pretty
quick extra credit).

### 3. üíØ add game history feature

[Production deploy](https://react-hooks-next.netlify.app/isolated/final/04.extra-3.tsx)

Open
[localhost:3000/isolated/final/04.extra-3.js](http://localhost:3000/isolated/final/04.extra-3.js)
and see that the extra version supports keeping a history of the game and allows
you to go backward and forward in time. See if you can implement that!

NOTE: This extra credit is one of the harder extra credits. Don't worry if you
struggle a bit on it!

üí∞ Tip, in the final example, we store the history of squares in an array of
arrays. `[[/* step 0 squares */], [/* step 1 squares */], ...etc]`, so we have
two states: `history` and `currentStep`.

üí∞ Tip, in the final example, we move the state management from the `Board`
component to the `Game` component and that helps a bit. Here's what the JSX
returned from the `Game` component is in the final version:

```javascript
return (
  <div className="game">
    <div className="game-board">
      <Board onClick={selectSquare} squares={currentSquares} />
      <button className="restart" onClick={restart}>
        restart
      </button>
    </div>
    <div className="game-info">
      <div>{status}</div>
      <ol>{moves}</ol>
    </div>
  </div>
)
```

But you don't have to do this exactly the same way I do it. Feel free to play
around with this one.

## ü¶â Feedback

Fill out
[the feedback form](https://ws.kcd.im/?ws=React%20Hooks%20%F0%9F%8E%A3&e=04%3A%20Real%20World%20Review%3A%20Tic%20Tac%20Toe&em=).
